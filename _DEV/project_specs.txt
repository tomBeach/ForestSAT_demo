======= ======= ======= ForestSat 2018 v2.0 ======= ======= =======


======= ======= ======= DATABASE ======= ======= =======
======= ======= ======= DATABASE ======= ======= =======
======= ======= ======= DATABASE ======= ======= =======


======= database mgmt =======

== authors
SELECT * FROM authors;
SELECT * FROM abstract_authors;
SELECT id, user_id, firstname, lastname FROM authors;

== users
SELECT id, firstname, lastname, admin, reviewer, created_at, confirmed_at FROM users;
SELECT id, lastname, confirmation_token, confirmed_at, confirmation_sent_at, unconfirmed_email FROM users;

== abstracts
SELECT id, reviewer1_id, reviewer2_id, reviewer1_rec, reviewer2_rec, reviewer1_grade, reviewer2_grade, reviewer1_comment, reviewer2_comment, reviewer1_keywords, reviewer2_keywords FROM abstracts;
SELECT id, reviewer1_id, reviewer2_id, corr_author_id, pres_author_id, invited, presentation_id FROM abstracts;
SELECT id, reviewer1_id, reviewer2_id, reviewer1_rec, reviewer2_rec, reviewer1_grade, reviewer2_grade, invited FROM abstracts;
SELECT authors.firstname, authors.lastname, abstract_authors.author_type FROM authors INNER JOIN abstract_authors ON authors.id = abstract_authors.author_id WHERE abstract_authors.abstract_id = '44';
SELECT abstracts.abs_title, abstract_authors.author_type FROM abstracts INNER JOIN abstract_authors ON abstracts.id = abstract_authors.abstract_id WHERE abstract_authors.author_id = '18';

== get table info
SELECT column_name, data_type from information_schema.columns WHERE table_name = 'affiliations';

UPDATE users SET admin = 'true' WHERE id = '1';
UPDATE abstracts SET reviewer1_id = nil WHERE id = '10';
UPDATE abstracts SET keyword_1 = 'forests' WHERE id = '78';

ALTER TABLE abstract_author RENAME TO abstract_authors;
ALTER TABLE messages RENAME sender_id_id TO sender_id;
ALTER TABLE presentations RENAME session_room TO session_room_id;
ALTER TABLE presentations ALTER COLUMN session_room_id TYPE integer USING session_room_id::integer;

== insert data
INSERT INTO presentations
    (session_org_id, session_chair_id, room_id, session_type, session_title, session_start, created_at, updated_at) VALUES
    ('18', '19', '1', 'special', 'session_title', current_timestamp, current_timestamp, current_timestamp);
INSERT INTO authors (firstname, lastname, created_at, updated_at) VALUES ('Joe', 'Biden', current_timestamp, current_timestamp);
INSERT INTO presentations (session_org_id, session_chair_id, room_id, session_type, session_title, session_start, created_at, updated_at) VALUES ('1', '2', '1', 'session_type', 'session_title', current_timestamp, current_timestamp, current_timestamp);
INSERT INTO rooms (room_name, room_floor, room_type, created_at, updated_at) VALUES ('R100', '1', 'big', current_timestamp, current_timestamp);
INSERT INTO keywords (keyword_name, keyword_category, created_at, updated_at) VALUES ('forest', '1', current_timestamp, current_timestamp);
INSERT INTO abstract_authors (author_id, abstract_id, author_type, created_at, updated_at) VALUES (7, 9, 'primary', current_timestamp, current_timestamp);


======= has_many through =======
has_many :group_users
has_many :users, :through => :group_users
has_many :group_users
has_many :groups, :before_add => :validates_group, :through => :group_users

sql = "SELECT authors.id, authors.firstname, authors.lastname, affiliations.institution, affiliations.department, abstract_authors.author_type FROM authors INNER JOIN abstract_authors ON authors.id = abstract_authors.author_id INNER JOIN affiliations ON authors.id = affiliations.author_id WHERE abstract_authors.abstract_id = " + @abstract[:id].to_s

sql = "SELECT authors.id, authors.firstname, authors.lastname, affiliations.institution, affiliations.department, abstract_authors.author_type FROM authors INNER JOIN abstract_authors ON authors.id = abstract_authors.author_id INNER JOIN affiliations ON authors.id = affiliations.author_id WHERE abstract_authors.abstract_id = " + @abstract[:id].to_s


======= Multiple to one table =======
class Abstract < ApplicationRecord
    belongs_to :reviewer1, :class_name => 'User'
    belongs_to :reviewer2, :class_name => 'User'
end
class User < ApplicationRecord
    has_many :abstracts_as_reviewer1, :class_name => 'Abstract', :foreign_key => 'reviewer1_id'
    has_many :abstracts_as_reviewer2, :class_name => 'Abstract', :foreign_key => 'reviewer2_id'
end

class User < ApplicationRecord
	has_many :jobs_as_client, :class_name => 'Job', :foreign_key => 'client_id'
    has_many :jobs_as_manager, :class_name => 'Job', :foreign_key => 'manager_id'
end
class Job < ApplicationRecord
    belongs_to :client, :class_name => 'User'
    belongs_to :manager, :class_name => 'User'
end


======= ======= ======= SPECS ======= ======= =======
======= ======= ======= SPECS ======= ======= =======
======= ======= ======= SPECS ======= ======= =======

======= changes 1/21 ======
• build in a character limit in the abstract text box?    ** Done (limit 2500 on input)
• FAQ -- not allowing anyone to attach anything – pdfs, graphics, etc? Just simple text right?  ** added placeholder links
• expand text edit box  ** changed to textarea, set larger size
• to edit the abstract you need to scroll down in that window – agree that it isn’t obvious.   Then again 99% of submitters won’t bother editing anyway.  ** moved button to bottom of window (visible without scrolling)
• add a link to general guidelines for submission on Maureen’s site under the “Submit Abstract” tab  ** added temp link
• add character limit reminders to this site and FAQ
• guidelines on word limits etc for this?
• go to a screen that says ‘Thanks for registering! Check your email to confirm your account!’
• edit abstract can only edit the authors / title / keywords -- add text editing  ** Done (added text area)

======= changes 1/5 ======
- Confirmation email a bit slow
• Confirmation email currently comes from Tom’s email address
• I could confirm my login via the confirmation email, but could not login from either chrome or firefox (on a PC)
• Info collected from submitter looks good overall
- Change “corresponding author” to “submitting author”
- Next to check box for “invited” (yes or no) want to allow them to choose from a drop down list of invited/special session titles (perhaps with organizer names next to title of session)
- Also want to give option for “would you like to be considered for a special session (y/n)” and the drop down list of special sessions.
• Want to add ability for review to confirm appropriates of author-submitted keywords
- Want to add ability for review to provide comments (assure that they are internal only, not to be shared with authors). May also want to include in comment instructions that they can suggest alternative keywords.

======= changes 12/3 =======
• New Abstract javascript pages
        sequence: title, authors, text, keywords/invited/requests
        character limits: 200(title), 2500(text)
        cancel button: move to far left (all screens)
        remove hard-wired input values
        add placeholders
        change input text styling (smaller, black)
        fix "invited" label
        "select up to 3 keywords"
        change "session type" to "preferred format"
        DEBUGGING: prev button submit
        corresponding authors are NOT primary/sec authors

• Edit Abstract
        allow multiple affiliations (join table)
    allow admin-only editing

• all
    change "corresponding author" to "submitter"

• My_Abstracts and All_Abstracts
        put all authors on line 2
        put only presenting author on line 1

• Users
        no affiliations (authors only)
        allow multiple affiliations for each author

• authors
        check uniqueness via email address

• Home page
    style changes


======= Functionality =======
- attendee should be able to login (username/password)
- submit abstract (title, authors + affiliations, abstract text, keywords, oral vs. poster, invited?)
- enter multiple secondary authors (via next button/temporary list)
- goes into database
- list email for primary author only
- reviewers are assigned abstracts to review
- reviewers read and grade abstracts (pass/fail)
- assign session to each accepted talk or poster

Database:
authors
- author name (last, first + middle, affiliation)
- author type (primary, secondary, submitting, presenting)
- presentation preference (oral, poster)
- invited or not
affiliation
- institution
- department
abstract
- title
- primary author
- secondary author
- submitting author
- presenting author
- abstract text
- accepted or not
abstract_authors
- author_id
- abstract_id

presentations (presentationGroup)
- presentation assignment (oral, poster)
- session ID -> (day, time, room)
- talk number in session

session entry
- session title
- session_id
- startTime
- room
- primary author

workflow
    admin
        assign reviewers
    reviewers
        make recommendation
    admin
        makes final disposition, assign session

reviewer
    list:
        assigned_abstract_id
        assigned_abstract_title
        primary author
        reviewer_rec (blank, O/P/R)
        grade (blank, E, VG, G, F, P)

    show:
        assigned_abstract_id
        assigned_abstract_title
        primary author
        assigned_abstract_text
        secondary author
        reviewer_rec (O/P/R) oral, poster, reject
        grade (E, VG, G, F, P) excellent, very good, good, fair, poor
        comment_text
        SAVE/CANCEL

administrator
    list:
        SELECT abstracts (by keyword/all)
        SELECT reviewer1 (defaults to selected)
        SELECT reviewer2 (defaults to selected)
        assigned_abstract_id
        assigned_abstract_title
        primary author
        reviewer1_rec (blank, O/P/R)
        reviewer1_grade (blank, E, VG, G, F, P)
        reviewer2_rec (blank, O/P/R)
        reviewer2_grade (blank, E, VG, G, F, P)
        admin_final SELECT (blank, O/P/R)
        SHOW abstract detail
        SESSION (popup to assign session/sequence)
        SELECT location (posters only)

    session:
        session
        sequence

    show:
        assigned_abstract_id
        assigned_abstract_title
        primary author
        assigned_abstract_text
        secondary author
        reviewer_rec (O/P/R) oral, poster, reject
        grade (E, VG, G, F, P) excellent, very good, good, fair, poor
        comment_text
        CLOSE


session detail
show talks in selected session


======= ======= ======= FORMS ======= ======= =======
======= ======= ======= FORMS ======= ======= =======
======= ======= ======= FORMS ======= ======= =======


== selectbox init ==
<% selected_reviewer_id1 = nil %>
<% if next_abstract[:reviewer1_id] %>
    <% selected_reviewer1 = User.find(next_abstract[:reviewer1_id]) %>
    <% selected_reviewer_id1 = selected_reviewer1[:id] %>
<% end %>
<% reviewer1 = User.find(next_abstract[:reviewer1_id]) %>
<% reviewer_name1 = reviewer1[:firstname] + " " + reviewer1[:lastname]%>

== form_for syntax ==
<%= form_for("save_selection", url: "/save_selection", :html => {:id => "save_selection"}) do %>

== sql for multi-table join data ==
sql = "SELECT authors.firstname, authors.lastname, abstract_authors.author_type FROM authors INNER JOIN abstract_authors ON authors.id = abstract_authors.author_id WHERE abstract_authors.abstract_id = '" + next_abstract[:id].to_s + "' AND abstract_authors.author_type = 'primary';"
author_data = ActiveRecord::Base.connection.execute(sql)

== multi-selectboxes to array for "save all" submit ==
<% admin_select_options = [nil, "oral", "poster", "rejected"] %>
<%= select_tag("abstract[admin_finals][]", options_for_select(admin_select_options, next_abstract[:admin_final]), :id => "abstract_admin_finals_" + next_abstract[:id].to_s) %>

<%= a.select(:reviewer1_id, options_for_select(user_name_ids, selected_reviewer_id1)) %>
<%= select_tag("abstract[reviewer1_ids][]", options_for_select(user_name_ids, selected_reviewer_id1), :id => "abstract_reviewer1_ids" + next_abstract[:id].to_s) %>

== strong params for single and multi form data submission ==
def selection_params
    puts "\n******* selection_params *******"
    params.require(:abstract).permit(:abstract_id, :admin_final, :admin_finals => [], :abstract_ids => [])
end

== strong params for multiple table data from the same form ==
def abstract_params
    puts "******* abstract_params *******"
    ok_params = []
    ok_params << params.require(:abstract).permit(:corr_author_id, :pres_author_id, :reviewer1_id, :reviewer2_id, :presentation_id, :session_sequence, :abs_title, :abs_text, :keyword_1, :keyword_2, :keyword_3, :new_keyword_1, :new_keyword_2, :new_keyword_3, :present_request, :present_assigned, :reviewer1_rec, :reviewer2_rec, :accepted, :invited, :paper)
    ok_params << params.require(:author).permit(:firstnames => [], :lastnames => [])
    ok_params << params.require(:affiliation).permit(:institutions => [], :departments => [])
    ok_params << params.require(:abstract_author).permit(:author_types => [])
    return ok_params
end


======= ======= ======= DATABASE info ======= ======= =======
======= ======= ======= DATABASE info ======= ======= =======
======= ======= ======= DATABASE info ======= ======= =======


======= foreign keys/relationships =======
The foreign key goes on the table for the class declaring the belongs_to association

class User < ApplicationRecord
    has_one :affiliation
end
class Affiliation < ApplicationRecord
    belongs_to :user
end
class CreateUsers < ActiveRecord::Migration[5.1]
  def change
    create_table :users do |t|
      t.string :firstname
    end
  end
end
class CreateAffiliations < ActiveRecord::Migration[5.1]
  def change
    create_table :affiliation do |t|
      t.references :user, foreign_key: true
    end
  end
end


======= tables and columns =======
abstract_authors
  t.bigint       "author_id"
  t.bigint       "abstract_id"
  t.string       "author_type"
end

abstracts
  t.bigint       "corr_author_id"
  t.bigint       "pres_author_id"
  t.bigint       "reviewer1_id"
  t.bigint       "reviewer2_id"
  t.bigint       "presentation_id"
  t.integer      "session_sequence"
  t.string       "abs_title"
  t.string       "abs_text"
  t.string       "keyword_1"
  t.string       "keyword_2"
  t.string       "keyword_3"
  t.string       "present_request"
  t.string       "present_assigned"
  t.string       "reviewer1_rec"
  t.string       "reviewer2_rec"
  t.string       "reviewer1_grade"
  t.string       "reviewer2_grade"
  t.string       "admin_final"
  t.boolean      "accepted"
  t.boolean      "invited"
  t.boolean      "paper"
end

affiliations
  t.bigint       "author_id"
  t.string       "institution"
  t.string       "department"
end

author_affiliations
  t.bigint       "author_id"
  t.bigint       "affiliation_id"
end

authors
  t.string       "firstname"
  t.string       "lastname"
  t.integer      "user_id"
end

keywords
  t.string       "keyword_name"
  t.string       "keyword_category"
end

presentations
  t.bigint       "session_org_id"
  t.bigint       "session_chair_id"
  t.bigint       "room_id"
  t.string       "session_type"
  t.string       "session_title"
  t.datetime     "session_start"
end

rooms
  t.string       "room_name"
  t.string       "room_floor"
  t.string       "room_type"
end

users
  t.string       "firstname"
  t.string       "lastname"
  t.string       "username"
  t.string       "password"
  t.boolean      "submitter"
  t.boolean      "reviewer"
  t.boolean      "admin"
  t.string       "email", default: "", null: false
  t.string       "encrypted_password", default: "", null: false
  t.string       "reset_password_token"
  t.datetime     "reset_password_sent_at"
  t.datetime     "remember_created_at"
  t.integer      "sign_in_count", default: 0, null: false
  t.datetime     "current_sign_in_at"
  t.datetime     "last_sign_in_at"
  t.inet         "current_sign_in_ip"
  t.inet         "last_sign_in_ip"
  t.string       "confirmation_token"
  t.datetime     "confirmed_at"
  t.datetime     "confirmation_sent_at"
  t.string       "unconfirmed_email"
  t.integer      "failed_attempts", default: 3, null: false
  t.string       "unlock_token"
  t.datetime     "locked_at"
end


======= ======= ======= RAILS ======= ======= =======
======= ======= ======= RAILS ======= ======= =======
======= ======= ======= RAILS ======= ======= =======


======= generator examples =======
One: one-to-many
    rails generate model User room_loc_name:string room_loc_number:string floor:string hall:string location:string
Many: one-to-many
    rails generate model Post user:references title:string content:text
One: one-to-many (more than one table)
    rails generate model Comment user:references post:references content:string
Multiple to one table:
    rails generate model Job user:references user:references port:references port:references name:string

======= generator actuals =======
rails generate model Author_affiliation author:references affiliation:references

rails generate model Keyword keyword_name:string keyword_category:string

rails generate model User firstname:string lastname:string username:string password:string user_type:string admin:boolean

rails generate devise:install
    Note: This generator will install an initializer (config/initializers/devise.rb) which describes all of Devise's configuration options.

rails generate devise User

rails generate devise:views

rails generate model Affiliation institution:string department:string

rails generate model Person affiliation:references firstname:string lastname:string

rails generate model Abstract user:references user:references session:references session_sequence:number abs_title:string abs_text:string keyword_1:string keyword_2:string keyword_3:string present_request:string present_assigned:string reviewer1_rec:string reviewer2_rec:string invited:boolean paper:boolean

rails generate model Abstract_person person:references abstract:references author_type:string

rails generate model Room name:string floor:string

rails generate model Session room:references abstract:references session_start:datetime session_type:string


======= fixes =======
rails generate migration AddReviewerGradesToAbstract
class AddUnlocktokenToUser < ActiveRecord::Migration[5.1]
    def change
        add_column :authors, :user_id, :integer
    end
end
rails generate migration AddAffiliationToUser


======= ENV variables =======
ENV['DB_NAME']: forestsat_prod
ENV["SECRET_KEY_BASE"]:
878c2e015c942058af8ac1b9ba9ff6778e6f408371d7ba556564c316c92b58f5c83e68429ae861d817bda4f689f557b767003c9da47e43363d4e6b7ca05f15a6

SECRET_KEY_BASE: 878c2e015c942058af8ac1b9ba9ff6778e6f408371d7ba556564c316c92b58f5c83e68429ae861d817bda4f689f557b767003c9da47e43363d4e6b7ca05f15a6


======= scaffold =======
rails generate scaffold_controller User
rails generate scaffold_controller Affiliation
rails generate scaffold_controller Room
rails generate scaffold_controller Session
rails generate scaffold_controller Abstract


======= devise library code =======
find devise:
find ~ -name devise
devise path:
cd /Users/thomasbeach/.rbenv/versions/2.4.0/lib/ruby/gems/2.4.0/gems/devise-4.3.0


======= ======= ======= CRUD ======= ======= =======
======= ======= ======= CRUD ======= ======= =======
======= ======= ======= CRUD ======= ======= =======

@user = User.order("created_at").last


======= ======= ======= MAIL ======= ======= =======
======= ======= ======= MAIL ======= ======= =======
======= ======= ======= MAIL ======= ======= =======

source: http://www.bogotobogo.com/RubyOnRails/RubyOnRails_Devise_Authentication_Sending_Confirmation_Email.php

======= config/environments/development.rb =======
In development environments, emails won't be sent by default. We will still be able to see their contents in the console though. To enable sending, we need to add the following line to config/environments/development.rb:

    # == config/environments/development.rb
    config.action_mailer.perform_deliveries = true

We also need to define default url options for the Devise mailer in our environment file:

    config.action_mailer.delivery_method = :smtp
    config.action_mailer.default_url_options = { host: 'localhost:3000' }

======= db/migrate/20171105132450_add_devise_to_users.rb =======
Edit the migration file. The code below is the key to sending the user a confirmation email and to help when the user locked out.  These migration file fields are required for the Confirmable and Lockable modules to operate correctly:
    ...
    ## Confirmable
    t.string   :confirmation_token
    t.datetime :confirmed_at
    t.datetime :confirmation_sent_at
    t.string   :unconfirmed_email # Only if using reconfirmable

    ## Lockable
    t.integer  :failed_attempts, default: 0, null: false # Only if lock strategy is :failed_attempts
    t.string   :unlock_token # Only if unlock strategy is :email or :both
    t.datetime :locked_at


======= migrations =======
rake db:migrate
    - creates the users table:                  create_table(:users)
    - assures unique email in database:         add_index(:users, :email, {:unique=>true})
    - assures unique token for password reset:  add_index(:users, :reset_password_token, {:unique=>true})


======= config/development.rb =======

    config.action_mailer.default_url_options = { host: ENV['MAIL_HOST'] }
    config.action_mailer.delivery_method = :smtp
    config.action_mailer.raise_delivery_errors = true
    config.action_mailer.smtp_settings = {
      user_name:      ENV['SENDMAIL_USERNAME'],
      password:       ENV['SENDMAIL_PASSWORD'],
      domain:         ENV['MAIL_HOST'],
      address:       'smtp.gmail.com',
      port:          '587',
      authentication: :plain,
      enable_starttls_auto: true
    }


======= .bash_profile =======

export SENDMAIL_USERNAME='tbeach2k@gmail.com'
export SENDMAIL_PASSWORD='password'
export MAIL_HOST='localhost:3000'


======= /config/environments/development.rb =======

config.action_mailer.default_url_options = { :host => 'localhost:3000' }
config.action_mailer.delivery_method = :smtp
config.action_mailer.smtp_settings = {:address => "localhost", :port => 1025}

http://localhost:3000/users/confirmation?confirmation_token=DR4M-wK9fiYbNer55VkM


======= /db/migrate/20171105132450_add_devise_to_users.rbclass =======

AddDeviseToUsers < ActiveRecord::Migration[5.1]
  def self.up
    change_table :users do |t|
      ## Database authenticatable
      ...

      ## Confirmable
      t.string   :confirmation_token
      t.datetime :confirmed_at
      t.datetime :confirmation_sent_at
      t.string   :unconfirmed_email # Only if using reconfirmable
  end
end


======= mailcatcher =======
- install the mailcatcher gem
- allows use of a SMTP server in development (catches incoming mails/displays on localhost)
- install mailcatcher
    gem install mailcatcher
- start the mailcatcher server
    mailcatcher
- A toy SMTP server will be running on port 1025 catching emails and displaing them on HTTP port 1080.
- In development Mailcatcher has a web interface on localhost:1080 that you can open and see the catched emails
- In production you want to use a real SMTP server (Google Apps, qmail, postfix...)


======= /config/environments/production.rb =======

config.action_mailer.default_url_options = {:host => 'yourdomain.com'}
config.action_mailer.delivery_method = :smtp
config.action_mailer.smtp_settings = {
  :address => "127.0.0.1",
  :port    => 25,
  :domain  => 'yourdomain.com'
}


======= /controllers/users_controller.rb =======
class UsersController < ApplicationController
    def create
        @user = User.new(params[:user])
        respond_to do |format|
            if @user.save
                UserMailer.welcome_email(@user).deliver_later       # send email after save
                format.html { redirect_to(@user, notice: 'User was successfully created.') }
            else
                format.html { render action: 'new' }
            end
        end
    end
end


config.action_mailer.delivery_method = :smtp
config.action_mailer.smtp_settings = {
  address:              'smtp.gmail.com',
  port:                 587,
  domain:               'example.com',
  user_name:            '<username>',
  password:             '<password>',
  authentication:       'plain',
  enable_starttls_auto: true  }

ActionMailer::Base.delivery_method = :smtp
ActionMailer::Base.smtp_settings = {

     :address => "smtp.gmail.com",
     :port => 587,
     :domain => "gmail.com",
     :user_name => "[username]",
     :password => "[password]",
     :authentication => :login,
     :tls => true
}


======= ======= ======= MISC ======= ======= =======
======= ======= ======= MISC ======= ======= =======
======= ======= ======= MISC ======= ======= =======

======= radiobuttons/checkboxes =======
<div class="field">
  <%= f.label :author_type %><br />
  primary <%= radio_button("user", "author_type", "primary") %>
  secondary <%= radio_button("user", "author_type", "secondary") %>
  presenting<%= check_box("user", "present") %>
  submitting <%= check_box("user", "submit") %>
</div>








======= ======= ======= ForestSat 2018 ======= ======= =======
======= ======= ======= ForestSat 2018 ======= ======= =======
======= ======= ======= ForestSat 2018 ======= ======= =======



======= generators =======
$ rails generate model RoomLoc room_loc_name:string room_loc_number:string floor:string hall:string location:string

$ rails generate model Affiliation institution:string department:string

$ rails generate model User affiliation_id:integer firstname:string lastname:string username:string password:string email:string invited:boolean

$ rails generate model Abstract abstract_title:string abstract_text:text primary_author:references secondary_author:references submitting_author:references presenting_author:references present_actual:string present_pref:string accepted:boolean

$ rails generate model Presentation abstract:references poster_location:string session_type:string session_code:string session_room:string session_datetime:datetime session_sequence:integer

======= ERD text =======
$ rails generate model RoomLoc room_loc_name:string room_loc_number:string floor:string hall:string location:string

    room_loc_name
    room_loc_number
    floor
    hall
    location

$ rails generate model Affiliation institution:string department:string

    institution
    department

$ rails generate model User firstname:string lastname:string username:string password:string email:string invited:boolean

    firstname
    lastname
    username
    password
    email
    invited

$ rails generate model Abstract abstract_title:string abstract_text:text primary_author:references secondary_author:references submitting_author:references presenting_author:references present_actual:string present_pref:string accepted:boolean

    abstract_title
    abstract_text
    primary_author
    secondary_author
    submitting_author
    presenting_author
    present_actual
    present_pref
    accepted

$ rails generate model Presentation abstract_id:references poster_location:string session_type:string session_code:string session_room:string session_datetime:datetime session_sequence:integer

    abstract_id
    poster_location
    session_type
    session_code
    session_room
    session_datetime
    session_sequence

======= schema =======
abstracts
    abstract_title
    abstract_text
    primary_author_id
    secondary_author_id
    submitting_author_id
    presenting_author_id
    present_actual
    present_pref
    accepted

affiliations
    institution
    department

presentations
    abstract_id
    poster_location
    session_type
    session_code
    session_room

users
    firstname
    lastname
    username
    password
    email
    invited
    affiliation_id
    admin

======= fixes =======

rails generate migration AddInvitedToAbstract
class AddInvitedToAbstract < ActiveRecord::Migration[5.1]
    def change
        add_column :abstracts, :invited, :boolean
    end
end
rails generate migration RemoveInvitedFromUser
class RemoveInvitedFromUser < ActiveRecord::Migration[5.1]
    def change
        remove_column :users, :invited, :boolean
    end
end



======= ======= ======= ARCHIVE ======= ======= =======
======= ======= ======= ARCHIVE ======= ======= =======
======= ======= ======= ARCHIVE ======= ======= =======

ActiveRecord::Schema.define(version: 20160126075418) do

== reference ==
  create_table "users", force: :cascade do |t|
    t.string   "email",                     default: "", null: false
    t.string   "encrypted_password",        default: "", null: false
    t.string   "reset_password_token"
    t.datetime "reset_password_sent_at"
    t.datetime "remember_created_at"
    t.integer  "sign_in_count",             default: 0,  null: false
    t.datetime "current_sign_in_at"
    t.datetime "last_sign_in_at"
    t.string   "current_sign_in_ip"
    t.string   "last_sign_in_ip"
    t.datetime "created_at",                null: false
    t.datetime "updated_at",                null: false
  end

  add_index "users", ["email"], name: "index_users_on_email", unique: true
  add_index "users", ["reset_password_token"], name: "index_users_on_reset_password_token", unique: true

== actual ==
  create_table "users", force: :cascade do |t|
    t.string "email",                       default: "", null: false
        t.string "unlock_token"
    t.string "encrypted_password",          default: "", null: false
    t.string "reset_password_token"
    t.datetime "reset_password_sent_at"
    t.datetime "remember_created_at"
    t.integer "sign_in_count",              default: 0, null: false
    t.datetime "current_sign_in_at"
    t.datetime "last_sign_in_at"
    t.inet "current_sign_in_ip"
    t.inet "last_sign_in_ip"
        t.string "confirmation_token"
        t.datetime "confirmed_at"
        t.datetime "confirmation_sent_at"
        t.string "unconfirmed_email"
        t.integer "affiliation_id"
        t.index ["confirmation_token"], name: "index_users_on_confirmation_token", unique: true
        t.index ["email"], name: "index_users_on_email", unique: true
        t.index ["reset_password_token"], name: "index_users_on_reset_password_token", unique: true
        t.index ["unlock_token"], name: "index_users_on_unlock_token", unique: true
    t.datetime "created_at", null: false
    t.datetime "updated_at", null: false
  end

end

$ rails generate migration AddAffiliationIdToUser affiliation:references

$ rails generate model Abstract_author user:references abstract:references poster_location:string session_type:string session_code:string session_room:string session_datetime:datetime session_sequence:integer

$ rails generate model Abstract_author
    author
    abstract

$ rails generate model Abstract_present
    author
    presentation

    present_type:string         (oral, poster)
    session_code:string         (session id)
    session_datetime:datetime   (timestamp)
    session_room:string         (link to rooms database?)
    poster_location:string      (location on area map/grid)
    session_sequence:integer    (first, second, third...)
